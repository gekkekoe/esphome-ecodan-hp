substitutions:
  update_interval_minutes: "10min"

number:
  # Safety limits
  - platform: template
    id: maximum_heating_flow_temp
    name: ${maximum_heating_flow_temp}
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 38.0
    min_value: 25.0
    max_value: 55.0
    step: 0.5
  - platform: template
    id: minimum_cooling_flow_temp
    name: ${minimum_cooling_flow_temp}
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 18.0
    min_value: 10.0
    max_value: 25.0
    step: 0.5
  - platform: template
    id: minimum_heating_flow_temp
    name: ${minimum_heating_flow_temp}
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 25.0
    min_value: 24.0
    max_value: 40.0
    step: 0.5
  - platform: template
    id: cooling_smart_start_temp
    unit_of_measurement: "°C"
    name: ${cooling_smart_start_temp}
    optimistic: true
    restore_value: true
    initial_value: 19.0
    min_value: 16.0
    max_value: 22.0
    step: 0.5
  - platform: template
    id: auto_adaptive_setpoint_bias
    unit_of_measurement: "°C"
    name: ${auto_adaptive_setpoint_bias}
    optimistic: true
    restore_value: true
    initial_value: 0.0
    min_value: -2.5
    max_value: 2.5
    step: 0.1
  # Temperature feedback via api
  - platform: template
    id: temperature_feedback_z1
    name: ${temperature_feedback} z1
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 20.0
    min_value: -50
    max_value: 100
    step: 0.1
  - platform: template
    id: temperature_feedback_z2
    name: ${temperature_feedback} z2
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 20.0
    min_value: -50
    max_value: 100
    step: 0.1

select:
  - platform: template
    id: temperature_feedback_source
    name: ${temperature_feedback_source}
    optimistic: true
    restore_value: true
    options:
      - "${temperature_feedback_option_room}"
      - "${select_feedback_option_api}"
    initial_option: "${temperature_feedback_option_room}"

  - platform: template
    id: heating_system_type
    name: ${heating_system_type}
    optimistic: true
    restore_value: true
    options:
      - "${heating_system_type_option_ufh}"
      - "${heating_system_type_option_ufh} *"
      - "${heating_system_type_option_ufh_rad}"
      - "${heating_system_type_option_ufh_rad} *"
      - "${heating_system_type_option_rad}" 
      - "${heating_system_type_option_rad} *"
    initial_option: "${heating_system_type_option_ufh}"
  
switch:
  - platform: template
    name: ${auto_adaptive_control_enabled}
    id: auto_adaptive_control_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

# button:
#   - platform: template
#     name: 'Auto-Adaptive: Run'
#     id: run_auto_adaptive_cycle
#     icon: "mdi:play-circle"
#     on_press:
#       then:
#         - script.execute: auto_adaptive_loop

interval:
  - interval: ${update_interval_minutes}
    then:
      - script.execute: auto_adaptive_loop

script:
  - id: auto_adaptive_loop
    # avoid multiple queues of this script, "restart" if current one needs to be cancelled
    mode: restart
    then:
      - lambda: |-
          if (!id(auto_adaptive_control_enabled).state) return;
          auto& status = id(ecodan_instance).get_status();

          if (status.Operation == esphome::ecodan::Status::OperationMode::DHW_ON
            || status.Operation == esphome::ecodan::Status::OperationMode::FROST_PROTECT
            || status.Operation == esphome::ecodan::Status::OperationMode::LEGIONELLA_PREVENTION) {
            ESP_LOGD("auto_adaptive", "No climate task. Exiting.");
            return;
          }

          if (status.DefrostActive || id(status_short_cycle_lockout).state) {
            ESP_LOGI("auto_adaptive", "Lockout or Defrost is active. Exiting.");
            return;
          }

          if (status.HeatingCoolingMode != esphome::ecodan::Status::HpMode::HEAT_FLOW_TEMP && 
              status.HeatingCoolingMode != esphome::ecodan::Status::HpMode::COOL_FLOW_TEMP) {
            ESP_LOGD("auto_adaptive", "Zone 1 is not in a fixed flow mode. Exiting.");
            return;
          }

          if (status.has_2zones() && 
            (status.HeatingCoolingModeZone2 != esphome::ecodan::Status::HpMode::HEAT_FLOW_TEMP && 
              status.HeatingCoolingModeZone2 != esphome::ecodan::Status::HpMode::COOL_FLOW_TEMP)) {
            ESP_LOGD("auto_adaptive", "Zone 2 is not in a fixed flow mode. Exiting.");
            return;
          }

          if (isnan(id(hp_feed_temp).state) || isnan(id(outside_temp).state)) {
            ESP_LOGW("auto_adaptive", "Sensor data unavailable. Exiting.");
            return;
          }

          ESP_LOGD("auto_adaptive", "Starting auto-adaptive cycle, z2 independent: %d, has_cooling: %d", status.has_independent_z2(), status.has_cooling());

          const float SATURATION_MARGIN = 2.0f;
          float user_defined_minimum_heating_flow_temp = id(minimum_heating_flow_temp).state;
          const float MIN_HEAT_FLOW = !isnan(user_defined_minimum_heating_flow_temp) && user_defined_minimum_heating_flow_temp >= 24.0f ? user_defined_minimum_heating_flow_temp : 24.0f;
          float max_flow_temp = id(maximum_heating_flow_temp).state;

          float actual_outside_temp = id(outside_temp).state;

          if (isnan(actual_outside_temp))
              return;

          auto heating_type_index = id(heating_system_type).active_index().value_or(0);
          float base_min_delta_t, max_delta_t, max_error_range, min_delta_cold_limit;

          if (heating_type_index <= 1) {
              base_min_delta_t = 2.25f;
              min_delta_cold_limit = 4.0f;
              max_delta_t = 6.0f; 
              max_error_range = 1.5f;
          } else if (heating_type_index <= 3) { 
              base_min_delta_t = 3.0f;
              min_delta_cold_limit = 5.0f;
              max_delta_t = 8.0f; 
              max_error_range = 2.0f;
          } else { 
              base_min_delta_t = 4.0f;
              min_delta_cold_limit = 6.0f;
              max_delta_t = 10.0f; 
              max_error_range = 2.5f;
          }

          const float MILD_WEATHER_TEMP = 15.0f;
          const float COLD_WEATHER_TEMP = -5.0f;
          float clamped_outside_temp = std::clamp(actual_outside_temp, COLD_WEATHER_TEMP, MILD_WEATHER_TEMP);
          float linear_cold_factor = (MILD_WEATHER_TEMP - clamped_outside_temp) / (MILD_WEATHER_TEMP - COLD_WEATHER_TEMP);          
          float cold_factor = linear_cold_factor * linear_cold_factor;
          float dynamic_min_delta_t = base_min_delta_t + (cold_factor * (min_delta_cold_limit - base_min_delta_t));

          float calculated_flows_heat[2] = {0.0f, 0.0f};
          float calculated_flows_cool[2] = {100.0f, 100.0f};

          esphome::ecodan::Zone all_zones[] = {esphome::ecodan::Zone::ZONE_1, esphome::ecodan::Zone::ZONE_2};
          auto max_zones = status.has_2zones() ? std::size(all_zones) : 1;
          auto multizone_status = status.MultiZoneStatus;

          for (std::size_t i = 0; i < max_zones; i++) {
              auto zone = all_zones[i];
              
              bool is_heating_mode = status.is_auto_adaptive_heating(zone);
              bool is_heating_active = status.Operation == esphome::ecodan::Status::OperationMode::HEAT_ON;
              bool is_cooling_mode = status.has_cooling() && status.is_auto_adaptive_cooling(zone);
              bool is_cooling_active = status.Operation == esphome::ecodan::Status::OperationMode::COOL_ON;

              // we need to check if the zone is actually operating
              // 0 = idle, 1 = both, 2 = z1, 3 = z2
              if (is_heating_active && status.has_independent_z2()) {
                if (i == 0 && (multizone_status == 0 || multizone_status == 3)) {
                  is_heating_active = false;
                }
                else if (i == 1 && (multizone_status == 0 || multizone_status == 2)) {
                  is_heating_active = false;
                }
              }
                  
              if (!is_heating_mode && !is_cooling_mode) continue;

              float setpoint_bias = id(auto_adaptive_setpoint_bias).state;
              if (isnan(setpoint_bias))
                setpoint_bias = 0.0f;

              float room_temp = (i == 0) ? status.Zone1RoomTemperature : status.Zone2RoomTemperature;
              float room_target_temp = (i == 0) ? status.Zone1SetTemperature : status.Zone2SetTemperature;
              float requested_flow_temp = (i == 0) ? status.Zone1FlowTemperatureSetPoint : status.Zone2FlowTemperatureSetPoint;
              float actual_flow_temp = status.has_independent_z2() ? ((i == 0) ? status.Z1FeedTemperature : status.Z2FeedTemperature) : id(hp_feed_temp).state;
              float actual_return_temp = status.has_independent_z2() ? ((i == 0) ? status.Z1ReturnTemperature : status.Z2ReturnTemperature) : id(hp_return_temp).state;
              
              if (id(temperature_feedback_source).active_index().value_or(0) == 1) {
                  room_temp = (i == 0) ? id(temperature_feedback_z1).state : id(temperature_feedback_z2).state;
              }
              if (isnan(room_temp) || isnan(room_target_temp) || isnan(requested_flow_temp) || isnan(actual_flow_temp)) continue;

              ESP_LOGD("auto_adaptive", "Processing Zone %d: Room=%.1f, Target=%.1f, Outside=%.1f, cold factor=%.2f, Bias=%.1f, heating: %d, cooling: %d",
                (i + 1), room_temp, room_target_temp, actual_outside_temp, cold_factor, setpoint_bias, is_heating_active, is_cooling_active);
              room_target_temp += setpoint_bias;

              float error = is_heating_mode ? (room_target_temp - room_temp)
                : (room_temp - room_target_temp); // Reversed for cooling

              bool use_linear_error = (heating_type_index % 2 != 0);
              float calculated_flow = NAN;
              float error_positive = fmax(error, 0.0f);
              float error_normalized = error_positive / max_error_range;
              float error_clamped_normalized = fmin(error_normalized, 1.0f);
              float error_factor = use_linear_error ? error_clamped_normalized : error_clamped_normalized * error_clamped_normalized;
              float target_delta_t = dynamic_min_delta_t + error_factor * (max_delta_t - dynamic_min_delta_t);

              if (is_heating_mode && is_heating_active) {
                if (isnan(actual_return_temp)) {
                    ESP_LOGE("auto_adaptive", "Z%d HEATING (Delta T): FAILED, actual_return_temp is NAN. Reverting to %.2f°C.", (i + 1), MIN_HEAT_FLOW);
                    calculated_flow = MIN_HEAT_FLOW;
                } else {
                    // detect and handle defrosts
                    const float DEFROST_RISK_MIN_TEMP = -2.0f;
                    const float DEFROST_RISK_MAX_TEMP = 3.0f;
                    const uint32_t DEFROST_MEMORY_MS = 1 * 3600000UL; // 1 hour

                    bool is_defrost_weather = false;
                    if (actual_outside_temp >= DEFROST_RISK_MIN_TEMP && actual_outside_temp <= DEFROST_RISK_MAX_TEMP) {
                        uint32_t last_defrost = id(_last_defrost_time);
                        if (last_defrost > 0 && (millis() - last_defrost) < DEFROST_MEMORY_MS) {
                            is_defrost_weather = true;
                        }
                    }

                    if (is_defrost_weather) {
                      // defrost weather detected, force to min delta T for the next hour
                      calculated_flow = actual_return_temp + base_min_delta_t;
                      // rounding
                      calculated_flow = floor(calculated_flow * 2) / 2.0f;
                      ESP_LOGW("auto_adaptive", "Z%d HEATING (Delta T): Defrost risk detected. Forcing minimum delta T (%.1f°C). Flow set to %.2f°C",
                                (i + 1), base_min_delta_t, calculated_flow);
                    } else {
                      // interpolate using quadratic error
                      calculated_flow = actual_return_temp + target_delta_t;
                      // rounding
                      calculated_flow = floor(calculated_flow * 2) / 2.0f;

                      float short_cycle_prevention_adjustment = id(predictive_short_cycle_total_adjusted);
                      if (short_cycle_prevention_adjustment > 0.0f) {
                        if ((actual_flow_temp - calculated_flow) >= 1.0f) {
                          calculated_flow += short_cycle_prevention_adjustment;
                        }
                        else {
                          // reset boost, calculated_flow is outside risky zone
                          id(predictive_short_cycle_total_adjusted) = 0;
                          short_cycle_prevention_adjustment = 0;
                        }
                      }
                      ESP_LOGD("auto_adaptive", "Z%d HEATING (Delta T): calculated_flow: %.2f°C (Return %.1f + Scaled  delta T %.2f, error factor: %.2f (lineair: %d), boost: %.1f)", 
                                (i + 1), calculated_flow, actual_return_temp, target_delta_t, error_factor, use_linear_error, short_cycle_prevention_adjustment);
                    }
                }

                // apply limits 
                if (calculated_flow > max_flow_temp) {
                  ESP_LOGW("auto_adaptive", "Z%d HEATING: Flow limited to %.1f°C (Safety Limit), calculated_flow: %.1f", (i + 1), max_flow_temp, calculated_flow);
                  calculated_flow = max_flow_temp;
                }

                if (calculated_flow < MIN_HEAT_FLOW) {
                  ESP_LOGW("auto_adaptive", "Z%d HEATING: Flow limited to %.1f°C (Min Limit), calculated_flow: %.1f", (i + 1), MIN_HEAT_FLOW, calculated_flow);
                  calculated_flow = MIN_HEAT_FLOW;
                }

                calculated_flows_heat[i] = calculated_flow;

              } else if (is_cooling_mode && is_cooling_active) {
                ESP_LOGD("auto_adaptive", "Using 'Delta-T Control' strategy for cooling.");
                
                if (isnan(actual_return_temp)) {
                  ESP_LOGE("auto_adaptive", "Z%d COOLING (Delta T): FAILED, actual_return_temp is NAN. Reverting to smart start temp.");
                  calculated_flow = id(cooling_smart_start_temp).state; // Failsafe
                } else {
                  // inverse of the heating
                  calculated_flow = actual_return_temp - target_delta_t;
                  
                  ESP_LOGD("auto_adaptive", "Z%d COOLING (Delta T): calc: %.1f°C (Return %.1f - Scaled delta T %.1f)", 
                            (i + 1), calculated_flow, actual_return_temp, target_delta_t);
                }
                if (calculated_flow > id(cooling_smart_start_temp).state) {
                  calculated_flow = id(cooling_smart_start_temp).state;
                  ESP_LOGD("auto_adaptive", "Z%d COOLING: Using Smart Start Temp of %.1f°C", (i + 1), calculated_flow);
                }
                if (calculated_flow < id(minimum_cooling_flow_temp).state) {
                  calculated_flow = id(minimum_cooling_flow_temp).state;
                  ESP_LOGW("auto_adaptive", "Z%d COOLING: Flow limited to %.1f°C (Condensation Limit)", (i + 1), calculated_flow);
                }
                calculated_flows_cool[i] = floor(calculated_flow * 2) / 2.0f;
              }
          }

          bool is_heating_demand = calculated_flows_heat[0] > 0.0f || calculated_flows_heat[1] > 0.0f;
          bool is_cooling_demand = calculated_flows_cool[0] < 100.0f || calculated_flows_cool[1] < 100.0f;

          if (status.has_independent_z2()) {
              if (is_heating_demand) {
                  if (status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_1) && status.Zone1FlowTemperatureSetPoint != calculated_flows_heat[0]) {
                    ESP_LOGD("auto_adaptive", "CMD: Set Z1 Heat Flow -> %.1f°C", calculated_flows_heat[0]);
                    id(ecodan_instance).set_flow_target_temperature(calculated_flows_heat[0], esphome::ecodan::Zone::ZONE_1);
                  }
                  if (status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_2) && status.Zone2FlowTemperatureSetPoint != calculated_flows_heat[1]) {
                    ESP_LOGD("auto_adaptive", "CMD: Set Z2 Heat Flow -> %.1f°C", calculated_flows_heat[1]);
                    id(ecodan_instance).set_flow_target_temperature(calculated_flows_heat[1], esphome::ecodan::Zone::ZONE_2);
                  }
              } else if (is_cooling_demand) {
                  if (status.is_auto_adaptive_cooling(esphome::ecodan::Zone::ZONE_1) && status.Zone1FlowTemperatureSetPoint != calculated_flows_cool[0]) {
                    ESP_LOGD("auto_adaptive", "CMD: Set Z1 Cool Flow -> %.1f°C", calculated_flows_cool[0]);
                    id(ecodan_instance).set_flow_target_temperature(calculated_flows_cool[0], esphome::ecodan::Zone::ZONE_1);
                  }
                  if (status.is_auto_adaptive_cooling(esphome::ecodan::Zone::ZONE_2) && status.Zone2FlowTemperatureSetPoint != calculated_flows_cool[1]) {
                    ESP_LOGD("auto_adaptive", "CMD: Set Z2 Cool Flow -> %.1f°C", calculated_flows_cool[1]);
                    id(ecodan_instance).set_flow_target_temperature(calculated_flows_cool[1], esphome::ecodan::Zone::ZONE_2);
                  }
              }
          } else {
              if (is_heating_demand) {
                  float final_flow = fmax(calculated_flows_heat[0], calculated_flows_heat[1]);
                  if (status.Zone1FlowTemperatureSetPoint != final_flow) {
                    ESP_LOGD("auto_adaptive", "CMD: Set Dependent Heat Flow -> %.1f°C (max of Z1:%.1f, Z2:%.1f)", final_flow, calculated_flows_heat[0], calculated_flows_heat[1]);
                    id(ecodan_instance).set_flow_target_temperature(final_flow, esphome::ecodan::Zone::ZONE_1);
                  }
              } else if (is_cooling_demand) {
                  float final_flow = fmin(calculated_flows_cool[0], calculated_flows_cool[1]);
                  if (status.Zone1FlowTemperatureSetPoint != final_flow) {
                    ESP_LOGD("auto_adaptive", "CMD: Set Dependent Cool Flow -> %.1f°C (min of Z1:%.1f, Z2:%.1f)", final_flow, calculated_flows_cool[0], calculated_flows_cool[1]);
                    id(ecodan_instance).set_flow_target_temperature(final_flow, esphome::ecodan::Zone::ZONE_1);
                  }
              }
          }
