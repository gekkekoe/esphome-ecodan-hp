globals:
  - id: optimizer_ptr
    type: esphome::optimizer::Optimizer*

  - id: lockout_expiration_timestamp
    type: uint32_t
    restore_value: yes
    initial_value: '0'

  - id: g_learned_heat_loss
    type: float
    restore_value: yes
    initial_value: '0.2'   # Default House Factor (kW/K)

  - id: g_learned_base_cop
    type: float
    restore_value: yes
    initial_value: '5'   # Default COP at 7C

  - id: g_learned_thermal_output
    type: float
    restore_value: yes
    initial_value: '6.0'   # Default Output (kW)

  - id: g_learned_elec_power
    type: float
    restore_value: yes
    initial_value: '1.5'   # Default Input Power (kW)

  - id: daily_compressor_runtime_minutes
    type: float
    restore_value: yes
    initial_value: '0.0'

substitutions:
  update_interval_minutes: "5min"
  asgard_prefix: "//"

esphome:
  on_boot:
      priority: 600
      then:
        - lambda: |-
            using namespace esphome::optimizer;
            OptimizerState state = {
                .learned_heat_loss_global = id(g_learned_heat_loss),
                .learned_base_cop_global = id(g_learned_base_cop),
                .learned_thermal_output_global = id(g_learned_thermal_output),
                .learned_elec_power_global = id(g_learned_elec_power),
                .lockout_expiration_timestamp = id(lockout_expiration_timestamp)
            };

            state.ecodan_instance = id(ecodan_instance);

            state.auto_adaptive_control_enabled = id(auto_adaptive_control_enabled);
            state.predictive_short_cycle_control_enabled = id(predictive_short_cycle_control_enabled);
            state.defrost_risk_handling_enabled = id(defrost_risk_handling_enabled);
            state.smart_boost_enabled = id(smart_boost_enabled);

            state.status_short_cycle_lockout = id(status_short_cycle_lockout);
            state.status_predictive_boost_active = id(status_predictive_boost_active);

            state.operation_mode = id(operation_mode);
            state.hp_feed_temp = id(hp_feed_temp);
            state.z1_feed_temp = id(z1_feed_temp);
            ${z2_cpp_prefix} state.z2_feed_temp = id(z2_feed_temp);
            ${asgard_prefix} state.asgard_vt_z1 = id(virtual_climate_z1);
            ${asgard_prefix} ${z2_cpp_prefix} state.asgard_vt_z2 = id(virtual_climate_z2);

            state.heating_system_type = id(heating_system_type);
            state.temperature_feedback_source = id(temperature_feedback_source);
            state.lockout_duration = id(lockout_duration);
            state.status_compressor = id(status_compressor);
            state.status_defrost = id(status_defrost);

            state.auto_adaptive_setpoint_bias = id(auto_adaptive_setpoint_bias);
            state.temperature_feedback_z1 = id(temperature_feedback_z1);
            state.temperature_feedback_z2 = id(temperature_feedback_z2);
            state.maximum_heating_flow_temp = id(maximum_heating_flow_temp);
            state.minimum_heating_flow_temp = id(minimum_heating_flow_temp);
            state.maximum_heating_flow_temp_z2 = id(maximum_heating_flow_temp_z2);
            state.minimum_heating_flow_temp_z2 = id(minimum_heating_flow_temp_z2);
            state.minimum_cooling_flow_temp = id(minimum_cooling_flow_temp);
            state.cooling_smart_start_temp = id(cooling_smart_start_temp);
            state.minimum_compressor_on_time = id(minimum_compressor_on_time);
            state.predictive_short_cycle_high_delta_time_window = id(predictive_short_cycle_high_delta_time_window);
            state.predictive_short_cycle_high_delta_threshold = id(predictive_short_cycle_high_delta_threshold);

            state.solver_kwh_meter_feedback_source = id(solver_kwh_meter_feedback_source);
            state.solver_kwh_meter_feedback = id(solver_kwh_meter_feedback); 
            state.daily_heating_produced = id(daily_computed_output_power);
            state.daily_heating_consumed = id(delta_energy_consumed_increasing);

            // instantiate optimizer
            id(optimizer_ptr) = new esphome::optimizer::Optimizer(state);
            
        - lambda: id(optimizer_ptr)->update_boost_sensor();
        - lambda: id(optimizer_ptr)->check_lockout_expiration();

# needed to trigger codegen
optimizer:

number:
  - platform: template
    id: maximum_heating_flow_temp
    name: ${maximum_heating_flow_temp}
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 35.0
    min_value: 25.0
    max_value: 55.0
    step: 0.5
  - platform: template
    id: minimum_heating_flow_temp
    name: ${minimum_heating_flow_temp}
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 25.0
    min_value: 24.0
    max_value: 40.0
    step: 0.5

  - platform: template
    id: maximum_heating_flow_temp_z2
    name: ${maximum_heating_flow_temp} z2
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 35.0
    min_value: 25.0
    max_value: 55.0
    step: 0.5
  - platform: template
    id: minimum_heating_flow_temp_z2
    name: ${minimum_heating_flow_temp} z2
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 25.0
    min_value: 24.0
    max_value: 40.0
    step: 0.5
  
  - platform: template
    id: minimum_cooling_flow_temp
    name: ${minimum_cooling_flow_temp}
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 18.0
    min_value: 10.0
    max_value: 25.0
    step: 0.5
  - platform: template
    id: cooling_smart_start_temp
    unit_of_measurement: "°C"
    name: ${cooling_smart_start_temp}
    optimistic: true
    restore_value: true
    initial_value: 19.0
    min_value: 16.0
    max_value: 22.0
    step: 0.5
  - platform: template
    id: auto_adaptive_setpoint_bias
    unit_of_measurement: "°C"
    name: ${auto_adaptive_setpoint_bias}
    optimistic: true
    restore_value: true
    initial_value: 0.0
    min_value: -2.5
    max_value: 2.5
    step: 0.1
  - platform: template
    id: temperature_feedback_z1
    name: ${temperature_feedback} z1
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 20.0
    min_value: -50
    max_value: 100
    step: 0.1
  - platform: template
    id: temperature_feedback_z2
    name: ${temperature_feedback} z2
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 20.0
    min_value: -50
    max_value: 100
    step: 0.1

  - platform: template
    id: minimum_compressor_on_time
    name: ${minimum_compressor_on_time}
    optimistic: true
    restore_value: true
    initial_value: 5 # minutes
    min_value: 1
    max_value: 20
    step: 1
  - platform: template
    id: predictive_short_cycle_high_delta_time_window
    name: ${predictive_short_cycle_high_delta_time_window}
    unit_of_measurement: "min"
    optimistic: true
    restore_value: true
    initial_value: 4.0
    min_value: 1.0
    max_value: 5.0
    step: 0.5
  - platform: template
    id: predictive_short_cycle_high_delta_threshold
    name: ${predictive_short_cycle_high_delta_threshold}
    unit_of_measurement: "°C"
    optimistic: true
    restore_value: true
    initial_value: 1.0
    min_value: 1.0
    max_value: 3.0
    step: 0.5
  - platform: template
    id: solver_kwh_meter_feedback
    name: ${solver_kwh_meter_feedback}
    unit_of_measurement: "kWh"
    optimistic: true
    restore_value: true
    initial_value: 0
    min_value: 0.0
    max_value: 9999
    step: 0.001
    mode: box

select:
  - platform: template
    id: temperature_feedback_source
    name: ${temperature_feedback_source}
    optimistic: true
    restore_value: true
    options:
      - "${temperature_feedback_option_room}"
      - "${select_feedback_option_api}"
      - "${select_feedback_option_asgard_vt}"
    initial_option: "${temperature_feedback_option_room}"

  - platform: template
    id: heating_system_type
    name: ${heating_system_type}
    optimistic: true
    restore_value: true
    options:
      - "${heating_system_type_option_ufh}"
      - "${heating_system_type_option_ufh} *"
      - "${heating_system_type_option_ufh_rad}"
      - "${heating_system_type_option_ufh_rad} *"
      - "${heating_system_type_option_rad}" 
      - "${heating_system_type_option_rad} *"
    initial_option: "${heating_system_type_option_ufh}"

  - platform: template
    id: lockout_duration
    name: ${lockout_duration}
    optimistic: true
    restore_value: true
    options:
      - "0"
      - "15"
      - "30"
      - "45"
      - "60"
    initial_option: "0"

  - platform: template
    id: solver_kwh_meter_feedback_source
    name: ${solver_kwh_meter_feedback_source}
    optimistic: true
    restore_value: true
    options:
      - "${solver_kwh_meter_option_internal}"
      - "${select_feedback_option_api}"
    initial_option: "${solver_kwh_meter_option_internal}"
  
switch:
  - platform: template
    name: ${auto_adaptive_control_enabled}
    id: auto_adaptive_control_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    name: ${predictive_short_cycle_control_enabled}
    id: predictive_short_cycle_control_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: if (id(optimizer_ptr) != nullptr) id(optimizer_ptr)->reset_predictive_boost();
    turn_off_action:
      - lambda: if (id(optimizer_ptr) != nullptr) id(optimizer_ptr)->reset_predictive_boost();

  - platform: template
    name: ${defrost_risk_handling_enabled}
    id: defrost_risk_handling_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    name: ${smart_boost_enabled}
    id: smart_boost_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

binary_sensor:
  - platform: template
    id: status_predictive_boost_active
    name: ${status_predictive_boost_active}
    lambda: |-
      return (id(optimizer_ptr) == nullptr) ? false : id(optimizer_ptr)->get_predictive_boost_state();
  - platform: ecodan
    status_short_cycle_lockout:
      id: status_short_cycle_lockout
      name: ${status_short_cycle_lockout}

button:
  - platform: template
    id: short_cycle_mitigation_button
    name: ${short_cycle_mitigation_button}
    on_press:
      - logger.log:
          level: INFO
          format: "Lockout script cancelled by button"
      - lambda: id(optimizer_ptr)->restore_svc_state();
  # - platform: template
  #   name: 'Auto-Adaptive: Run'
  #   id: run_auto_adaptive_cycle
  #   icon: "mdi:play-circle"
  #   on_press:
  #     then:
  #     - lambda: |-
  #         id(optimizer_ptr)->run_auto_adaptive_loop();

  # - platform: template
  #   name: "Short-Cycle: Start Compressor (Simulated)"
  #   on_press:
  #     - lambda: |-
  #         id(status_compressor).publish_state(true);

  # - platform: template
  #   name: "Short-Cycle: Stop Compressor (Simulated)"
  #   on_press:
  #     - lambda: |-
  #         id(status_compressor).publish_state(false);
interval:
  - interval: ${update_interval_minutes}
    then:
      - lambda: id(optimizer_ptr)->run_auto_adaptive_loop();
  - interval: 30s
    then:
      - lambda: id(optimizer_ptr)->check_lockout_expiration();
      - lambda: id(optimizer_ptr)->predictive_short_cycle_check();
      - lambda: id(optimizer_ptr)->update_boost_sensor();
      - lambda: id(optimizer_ptr)->update_heat_model();