globals:
  - id: predictive_delta_start_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  # For short-cycle detection
  - id: compressor_start_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: predictive_short_cycle_total_adjusted
    type: float
    restore_value: yes
    initial_value: '0.0'

button:
  - platform: template
    id: short_cycle_mitigation_button
    name: ${short_cycle_mitigation_button}
    on_press:
      - logger.log:
          level: INFO
          format: "Lockout script cancelled by button"
      - script.stop: short_cycle_mitigation_script
      - script.execute: restore_svc_state

  # - platform: template
  #   name: "Short-Cycle: Start Compressor (Simulated)"
  #   on_press:
  #     - lambda: |-
  #         id(status_compressor).publish_state(true);

  # - platform: template
  #   name: "Short-Cycle: Stop Compressor (Simulated)"
  #   on_press:
  #     - lambda: |-
  #         id(status_compressor).publish_state(false);

switch:
  - platform: template
    name: ${predictive_short_cycle_control_enabled}
    id: predictive_short_cycle_control_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(predictive_short_cycle_total_adjusted) = 0.0f;
    turn_off_action:
      - lambda: |-
         id(predictive_short_cycle_total_adjusted) = 0.0f;

number:
  - platform: template
    # Short-cycle protection
    id: minimum_compressor_on_time
    name: ${minimum_compressor_on_time}
    optimistic: true
    restore_value: true
    initial_value: 5 # minutes
    min_value: 1
    max_value: 20
    step: 1
  - platform: template
    id: predictive_short_cycle_high_delta_time_window
    name: ${predictive_short_cycle_high_delta_time_window}
    unit_of_measurement: "min"
    optimistic: true
    restore_value: true
    initial_value: 4.0
    min_value: 1.0
    max_value: 5.0
    step: 0.5

select:
  - platform: template
    id: lockout_duration
    name: ${lockout_duration}
    optimistic: true
    restore_value: true
    options:
      - "0"
      - "15"
      - "30"
      - "45"
      - "60"
    initial_option: "0"

interval:
  - interval: 30s
    then:
      - script.execute: predictive_short_cycle_check

script:
  - id: predictive_short_cycle_check
    mode: single
    then:
      - lambda: |-
          if (!id(auto_adaptive_control_enabled).state && !id(predictive_short_cycle_control_enabled).state) return;

          auto& status = id(ecodan_instance).get_status();
          auto start_time = id(predictive_delta_start_time);

          if (status.DefrostActive || id(status_short_cycle_lockout).state || !id(status_compressor).state) {
            //ESP_LOGD("predictive_short_cycle", "No Compressor activity or Lockout/Defrost active. Exiting.");
            if (start_time > 0)
              id(predictive_delta_start_time) = 0; // Reset the timer
            return;
          }
          
          if (!status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_1) && !status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_2)) {
            //ESP_LOGD("predictive_short_cycle", "Not in heating mode. Exiting.");
            if (start_time > 0)
              id(predictive_delta_start_time) = 0; // Reset the timer
            return;
          }

          if (status.Operation != esphome::ecodan::Status::OperationMode::HEAT_ON) {
            //ESP_LOGD("predictive_short_cycle", "No active heating. Exiting.");
            if (start_time > 0)
              id(predictive_delta_start_time) = 0; // Reset the timer
            return;  
          }

          float requested_flow = status.Zone1FlowTemperatureSetPoint;
          if (status.has_2zones()) {
            requested_flow = fmax(status.Zone1FlowTemperatureSetPoint, status.Zone2FlowTemperatureSetPoint);
          }
          
          float actual_flow = status.has_2zones() 
            ? fmax(status.Z1FeedTemperature, status.Z2FeedTemperature) 
            : id(hp_feed_temp).state;

          if (isnan(requested_flow) || isnan(actual_flow)) {
            ESP_LOGW("predictive_short_cycle", "Requested or Actual feed temperature unavailable. Exiting.");
            if (start_time > 0)
              id(predictive_delta_start_time) = 0; // Reset the timer
            return;
          }
          
          const float PREDICTIVE_DELTA_THRESHOLD = 1.0f;
          float time_window_setting = id(predictive_short_cycle_high_delta_time_window).state;
          if (isnan(time_window_setting) || time_window_setting < 1.0f || time_window_setting > 5.0f) {
            ESP_LOGE("predictive_short_cycle", "Corrupt value for time_window: %.2f. Reverting to 4.0", time_window_setting);
            time_window_setting = 4.0f; 
          }
          uint32_t trigger_duration_ms = time_window_setting * 60000UL; 

          float delta = actual_flow - requested_flow;
          const float adjustment_factor = 0.5f;


          if (delta >= PREDICTIVE_DELTA_THRESHOLD) {
            if (id(predictive_delta_start_time) == 0) {
              id(predictive_delta_start_time) = millis();
              ESP_LOGD("predictive_short_cycle", "High Delta T detected (%.1f°C). Starting timer.", delta);
            } else {
              if ((millis() - id(predictive_delta_start_time)) >= trigger_duration_ms) {
                ESP_LOGW("predictive_short_cycle", "Short-cycle predicted! Increasing offset to force a longer cycle.");
                id(predictive_delta_start_time) = 0;

                // in Auto Adaptive, increase offset
                if (id(auto_adaptive_control_enabled).state ) {
                  if (status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_1)) {
                    id(heating_curve_offset_z1) += 0.5f;
                  }
                  if (status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_2)) {
                    id(heating_curve_offset_z2) += 0.5f;
                  }

                  // apply new offsets to feed temp
                  id(auto_adaptive_loop).execute();

                } else if (id(predictive_short_cycle_control_enabled).state) {
                  // in fixed flow mode increase setpoint directly and save for restore
                  id(predictive_short_cycle_total_adjusted) += adjustment_factor;
                  
                  float adjusted_flow_z1 = status.Zone1FlowTemperatureSetPoint + adjustment_factor;
                  ESP_LOGD("predictive_short_cycle", "CMD: Increase Z1 Heat Flow to -> %.1f°C", adjusted_flow_z1);
                  id(ecodan_instance).set_flow_target_temperature(adjusted_flow_z1, esphome::ecodan::Zone::ZONE_1);
                  
                  if (status.has_independent_z2()) {
                    float adjusted_flow_z2 = status.Zone2FlowTemperatureSetPoint + adjustment_factor;
                    ESP_LOGD("predictive_short_cycle", "CMD: Increase Z2 Heat Flow to -> %.1f°C", adjusted_flow_z2);
                    id(ecodan_instance).set_flow_target_temperature(adjusted_flow_z2, esphome::ecodan::Zone::ZONE_2);
                  }
                }
              }
            }
          } else {
            if (start_time != 0) {
              ESP_LOGD("predictive_short_cycle", "High Delta T has disappeared. Resetting timer.");
              id(predictive_delta_start_time) = 0;
            }
          }

# lockout feature
  - id: short_cycle_mitigation_script
    mode: single
    then:
      - logger.log:
          level: WARN
          format: "Short-cycling detected! Starting a lockout for %s minutes."
          args: [ id(lockout_duration).state.c_str() ]
      - lambda: |-
          auto& status = id(ecodan_instance).get_status();
          auto flag = status.get_svc_flags();

          // we are already in svc, need to backup the old flags for restore.
          if (status.ServerControl)
            id(ecodan_instance).set_svc_state_before_lockout(flag);
          else
            id(ecodan_instance).reset_svc_state_before_lockout();

          if (status.is_heating(esphome::ecodan::Zone::ZONE_1))
            flag |= esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_Z1_HEATING;
          else if (status.is_cooling(esphome::ecodan::Zone::ZONE_1))
            flag |= esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_Z1_COOLING;

          if (status.is_heating(esphome::ecodan::Zone::ZONE_2))
            flag |= esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_Z2_HEATING;
          else if (status.is_cooling(esphome::ecodan::Zone::ZONE_2))
            flag |= esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_Z2_COOLING;
          
          flag |= esphome::ecodan::CONTROLLER_FLAG::SERVER_CONTROL;
          id(ecodan_instance).set_controller_mode(flag, true);
          
      - delay: !lambda "return atoi(id(lockout_duration).state.c_str()) * 60 * 1000;"
      - logger.log:
          level: INFO
          format: "Lockout period over. Restoring operations."
      - script.execute: restore_svc_state

  - id: restore_svc_state
    mode: single
    then:
      - logger.log:
          level: INFO
          format: "Executing restore states after lockout"
      - lambda: |-
          auto flag_before_lockout = id(ecodan_instance).get_svc_state_before_lockout();

          if (flag_before_lockout.has_value()) {
            auto flag = *flag_before_lockout;
            flag |= esphome::ecodan::CONTROLLER_FLAG::SERVER_CONTROL;
            id(ecodan_instance).set_controller_mode(flag, true);
          } else {
            id(ecodan_instance).set_controller_mode(esphome::ecodan::CONTROLLER_FLAG::SERVER_CONTROL, false);
          }
          id(status_short_cycle_lockout).publish_state(false);

# compressor stop event handler
  - id: on_compressor_stop
    mode: single
    then:
      - lambda: |-
          ESP_LOGD("predictive_short_cycle", "Running compressor stop logic...");
          auto& status = id(ecodan_instance).get_status();

          // if we had adjustment prior to the end-cycle, restore the flow temperatures
          bool stand_alone_predictive_active = !id(auto_adaptive_control_enabled).state && id(predictive_short_cycle_control_enabled).state;
          float adjustment = id(predictive_short_cycle_total_adjusted);

          if (stand_alone_predictive_active && adjustment > 0.0f) {  
            ESP_LOGD("predictive_short_cycle", "Restoring flow setpoint after predictive boost.");
          
            // Subtract the total adjusted amount from the current setpoints            
            float restored_flow_z1 = status.Zone1FlowTemperatureSetPoint - adjustment;
            id(ecodan_instance).set_flow_target_temperature(restored_flow_z1, esphome::ecodan::Zone::ZONE_1);
            
            if (status.has_independent_z2()) {
              float restored_flow_z2 = status.Zone2FlowTemperatureSetPoint - adjustment;
              id(ecodan_instance).set_flow_target_temperature(restored_flow_z2, esphome::ecodan::Zone::ZONE_2);
            }                      
            // Reset the counter
            id(predictive_short_cycle_total_adjusted) = 0.0f;
          }

          // exit if lockout is disabled
          if (id(lockout_duration).active_index().value_or(0) == 0) {
            id(compressor_start_time) = 0;
            return; // 0 duration == disabled
          }

          if (id(compressor_start_time) == 0 || id(status_short_cycle_lockout).state || status.DefrostActive)
            return;

          uint32_t min_duration_ms = id(minimum_compressor_on_time).state * 60000;
          if (min_duration_ms == 0)
            return;

          if (status.is_heating(esphome::ecodan::Zone::ZONE_1) 
            || status.is_cooling(esphome::ecodan::Zone::ZONE_1)
            || status.is_heating(esphome::ecodan::Zone::ZONE_2) 
            || status.is_cooling(esphome::ecodan::Zone::ZONE_2)) {

              uint32_t run_duration_ms = millis() - id(compressor_start_time);
              if (run_duration_ms < min_duration_ms) {
                id(compressor_start_time) = 0; 
                id(status_short_cycle_lockout).publish_state(true);
                id(short_cycle_mitigation_script).execute();
              }
          }

binary_sensor:
  - platform: ecodan
    status_short_cycle_lockout:
      id: status_short_cycle_lockout
      name: ${status_short_cycle_lockout}
    status_compressor:
      id: status_compressor
      name: ${status_compressor}
      # OFF -> ON
      on_press:
        then:
          - lambda: |-
              auto& status = id(ecodan_instance).get_status();
              if (!status.DefrostActive) {
                ESP_LOGI(esphome::ecodan::TAG, "Compressor START detected");
                id(compressor_start_time) = millis();
              }
      # ON -> OFF
      on_release:
        then:
          - lambda: |-
              ESP_LOGI(esphome::ecodan::TAG, "Compressor STOP detected");
              id(on_compressor_stop).execute();
