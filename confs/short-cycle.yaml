globals:
  - id: predictive_delta_start_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  # For short-cycle detection
  - id: compressor_start_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: predictive_short_cycle_total_adjusted
    type: float
    restore_value: yes
    initial_value: '0.0'
  # store last defrost time
  - id: _last_defrost_time
    type: uint32_t
    restore_value: yes
    initial_value: '-1'
  - id: lockout_expiration_timestamp
    type: uint32_t
    restore_value: yes
    initial_value: '0'

button:
  - platform: template
    id: short_cycle_mitigation_button
    name: ${short_cycle_mitigation_button}
    on_press:
      - logger.log:
          level: INFO
          format: "Lockout script cancelled by button"
      - script.stop: short_cycle_mitigation_script
      - script.execute: restore_svc_state

  # - platform: template
  #   name: "Short-Cycle: Start Compressor (Simulated)"
  #   on_press:
  #     - lambda: |-
  #         id(status_compressor).publish_state(true);

  # - platform: template
  #   name: "Short-Cycle: Stop Compressor (Simulated)"
  #   on_press:
  #     - lambda: |-
  #         id(status_compressor).publish_state(false);

switch:
  - platform: template
    name: ${predictive_short_cycle_control_enabled}
    id: predictive_short_cycle_control_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(predictive_short_cycle_total_adjusted) = 0.0f;
    turn_off_action:
      - lambda: |-
         id(predictive_short_cycle_total_adjusted) = 0.0f;

number:
  - platform: template
    # Short-cycle protection
    id: minimum_compressor_on_time
    name: ${minimum_compressor_on_time}
    optimistic: true
    restore_value: true
    initial_value: 5 # minutes
    min_value: 1
    max_value: 20
    step: 1
  - platform: template
    id: predictive_short_cycle_high_delta_time_window
    name: ${predictive_short_cycle_high_delta_time_window}
    unit_of_measurement: "min"
    optimistic: true
    restore_value: true
    initial_value: 4.0
    min_value: 1.0
    max_value: 5.0
    step: 0.5

select:
  - platform: template
    id: lockout_duration
    name: ${lockout_duration}
    optimistic: true
    restore_value: true
    options:
      - "0"
      - "15"
      - "30"
      - "45"
      - "60"
    initial_option: "0"

interval:
  - interval: 30s
    then:
      - script.execute: check_lockout_expiration
      - script.execute: predictive_short_cycle_check
      - lambda: |-
          id(status_predictive_boost_active).publish_state(id(predictive_short_cycle_total_adjusted) > 0.0f);

script:
  - id: predictive_short_cycle_check
    mode: single
    then:
      - lambda: |-
          if (!id(predictive_short_cycle_control_enabled).state) return;

          auto& status = id(ecodan_instance).get_status();
          auto start_time = id(predictive_delta_start_time);

          if (status.DefrostActive || id(status_short_cycle_lockout).state || !id(status_compressor).state) {
            //ESP_LOGD("predictive_short_cycle", "No Compressor activity or Lockout/Defrost active. Exiting.");
            if (status.DefrostActive) {
              ESP_LOGD("predictive_short_cycle", "Defrost detected, updating timestamp.");
              id(_last_defrost_time) = status.timestamp();
            }

            if (start_time > 0)
              id(predictive_delta_start_time) = 0; // Reset the timer
            return;
          }
          
          if (!status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_1) && !status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_2)) {
            //ESP_LOGD("predictive_short_cycle", "Not in heating mode. Exiting.");
            if (start_time > 0)
              id(predictive_delta_start_time) = 0; // Reset the timer
            return;
          }

          if (status.Operation != esphome::ecodan::Status::OperationMode::HEAT_ON) {
            //ESP_LOGD("predictive_short_cycle", "No active heating. Exiting.");
            if (start_time > 0)
              id(predictive_delta_start_time) = 0; // Reset the timer
            return;  
          }

          float requested_flow = status.Zone1FlowTemperatureSetPoint;
          if (status.has_2zones()) {
            requested_flow = fmax(status.Zone1FlowTemperatureSetPoint, status.Zone2FlowTemperatureSetPoint);
          }
          
          float actual_flow = status.has_2zones() 
            ? fmax(status.Z1FeedTemperature, status.Z2FeedTemperature) 
            : id(hp_feed_temp).state;

          if (isnan(requested_flow) || isnan(actual_flow)) {
            ESP_LOGW("predictive_short_cycle", "Requested or Actual feed temperature unavailable. Exiting.");
            if (start_time > 0)
              id(predictive_delta_start_time) = 0; // Reset the timer
            return;
          }
          
          const float PREDICTIVE_DELTA_THRESHOLD = 1.0f;
          float time_window_setting = id(predictive_short_cycle_high_delta_time_window).state;
          if (isnan(time_window_setting) || time_window_setting < 1.0f || time_window_setting > 5.0f) {
            ESP_LOGE("predictive_short_cycle", "Corrupt value for time_window: %.2f. Reverting to 4.0", time_window_setting);
            time_window_setting = 4.0f; 
          }
          uint32_t trigger_duration_ms = time_window_setting * 60000UL; 

          float delta = actual_flow - requested_flow;
          const float adjustment_factor = 0.5f;


          if (delta >= PREDICTIVE_DELTA_THRESHOLD) {
            if (id(predictive_delta_start_time) == 0) {
              id(predictive_delta_start_time) = millis();
              ESP_LOGD("predictive_short_cycle", "High Delta T detected (%.1f°C). Starting timer.", delta);
            } else {
              if ((millis() - id(predictive_delta_start_time)) >= trigger_duration_ms) {
                ESP_LOGW("predictive_short_cycle", "Short-cycle predicted! Increasing Feed temps to force a longer cycle.");
                id(predictive_delta_start_time) = 0;

                // in Auto Adaptive, increase feed temp
                if (id(auto_adaptive_control_enabled).state) {
                  // when using delta T, we need to boost the feed temp directly

                  bool was_boosted = false;
                  // 0 = idle, 1 = both, 2 = z1, 3 = z2
                  auto multizone_status = status.MultiZoneStatus;
                  if (status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_1) && (!status.has_independent_z2() || (status.has_independent_z2() && (multizone_status == 1 || multizone_status == 2)))) {
                    float adjusted_flow_z1 = status.Zone1FlowTemperatureSetPoint + adjustment_factor;
                    ESP_LOGD("predictive_short_cycle", "(Delta T) CMD: Increase Z1 Heat Flow to -> %.1f°C", adjusted_flow_z1);
                    id(ecodan_instance).set_flow_target_temperature(adjusted_flow_z1, esphome::ecodan::Zone::ZONE_1);
                    was_boosted = true;
                  }
                  if (status.is_auto_adaptive_heating(esphome::ecodan::Zone::ZONE_2) && (!status.has_independent_z2() || (status.has_independent_z2() && (multizone_status == 1 || multizone_status == 3)))) {
                    float adjusted_flow_z2 = status.Zone2FlowTemperatureSetPoint + adjustment_factor;
                    ESP_LOGD("predictive_short_cycle", "(Delta T) CMD: Increase Z2 Heat Flow to -> %.1f°C", adjusted_flow_z2);
                    id(ecodan_instance).set_flow_target_temperature(adjusted_flow_z2, esphome::ecodan::Zone::ZONE_2);
                    was_boosted = true;
                  }
                  // set boost adjustment, to be used in auto adaptive loop
                  if (was_boosted) 
                    id(predictive_short_cycle_total_adjusted) += adjustment_factor;

                } else if (id(predictive_short_cycle_control_enabled).state) {
                  // in fixed flow mode increase setpoint directly and save for restore
                  id(predictive_short_cycle_total_adjusted) += adjustment_factor;
                  
                  float adjusted_flow_z1 = status.Zone1FlowTemperatureSetPoint + adjustment_factor;
                  ESP_LOGD("predictive_short_cycle", "CMD: Increase Z1 Heat Flow to -> %.1f°C", adjusted_flow_z1);
                  id(ecodan_instance).set_flow_target_temperature(adjusted_flow_z1, esphome::ecodan::Zone::ZONE_1);
                  
                  if (status.has_independent_z2()) {
                    float adjusted_flow_z2 = status.Zone2FlowTemperatureSetPoint + adjustment_factor;
                    ESP_LOGD("predictive_short_cycle", "CMD: Increase Z2 Heat Flow to -> %.1f°C", adjusted_flow_z2);
                    id(ecodan_instance).set_flow_target_temperature(adjusted_flow_z2, esphome::ecodan::Zone::ZONE_2);
                  }
                }
              }
            }
          } else {
            if (start_time != 0) {
              ESP_LOGD("predictive_short_cycle", "High Delta T has disappeared. Resetting timer.");
              id(predictive_delta_start_time) = 0;
            }
          }

# lockout feature
  - id: short_cycle_mitigation_script
    mode: single
    then:
      - logger.log:
          level: WARN
          format: "Short-cycling detected! Starting a lockout for %s minutes."
          args: [ id(lockout_duration).state.c_str() ]
      - lambda: |-
          auto& status = id(ecodan_instance).get_status();
          auto flag = status.get_svc_flags();
          time_t current_timestamp = status.timestamp(); 

          if (current_timestamp == -1) {
            ESP_LOGW("short_cycle_mitigation", "Cannot start lockout: Ecodan controller time is not valid!");
            return; 
          }

          // we are already in svc, need to backup the old flags for restore.
          if (status.ServerControl)
            id(ecodan_instance).set_svc_state_before_lockout(flag);
          else
            id(ecodan_instance).reset_svc_state_before_lockout();

          if (status.is_heating(esphome::ecodan::Zone::ZONE_1))
            flag |= esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_Z1_HEATING;
          else if (status.is_cooling(esphome::ecodan::Zone::ZONE_1))
            flag |= esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_Z1_COOLING;

          if (status.is_heating(esphome::ecodan::Zone::ZONE_2))
            flag |= esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_Z2_HEATING;
          else if (status.is_cooling(esphome::ecodan::Zone::ZONE_2))
            flag |= esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_Z2_COOLING;
          
          flag |= esphome::ecodan::CONTROLLER_FLAG::SERVER_CONTROL;
          id(ecodan_instance).set_controller_mode(flag, true);
  
          uint32_t duration_s = atoi(id(lockout_duration).state.c_str()) * 60UL;
          if (duration_s > 0) {
            id(lockout_expiration_timestamp) = (uint32_t)(current_timestamp + duration_s);
            ESP_LOGI("short_cycle_mitigation", "Lockout active. Expiration timestamp set to: %u", id(lockout_expiration_timestamp));
          }

  - id: restore_svc_state
    mode: single
    then:
      - logger.log:
          level: INFO
          format: "Executing restore states after lockout"
      - lambda: |-
          auto flag_before_lockout = id(ecodan_instance).get_svc_state_before_lockout();

          if (flag_before_lockout.has_value()) {
            auto flag = *flag_before_lockout;

            // dhw could have changed during lockout, use the current bit
            auto& status = id(ecodan_instance).get_status();
            auto current_flag = status.get_svc_flags();
            auto dhw_mask = esphome::ecodan::CONTROLLER_FLAG::PROHIBIT_DHW;
            flag = (flag & ~dhw_mask) | (current_flag & dhw_mask);

            flag |= esphome::ecodan::CONTROLLER_FLAG::SERVER_CONTROL;
            id(ecodan_instance).set_controller_mode(flag, true);
          } else {
            id(ecodan_instance).set_controller_mode(esphome::ecodan::CONTROLLER_FLAG::SERVER_CONTROL, false);
          }
          // reset timer manually
          id(lockout_expiration_timestamp) = 0;
          id(status_short_cycle_lockout).publish_state(false);

  - id: check_lockout_expiration
    mode: single
    then:
      - lambda: |-
          uint32_t expiration = id(lockout_expiration_timestamp);
          
          if (expiration == 0)
            return;

          auto& status = id(ecodan_instance).get_status();
          time_t current_time_signed = status.timestamp(); 

          if (current_time_signed == -1) {
            ESP_LOGW("short_cycle_mitigation", "Cannot check lockout: Ecodan time is not valid. Retrying in 30s.");
            return; 
          }

          uint32_t current_time = (uint32_t)current_time_signed;

          if (current_time >= expiration) {
            // expired
            ESP_LOGI("short_cycle_mitigation", "Lockout period has expired (Ecodan Time: %u, Expiration: %u). Restoring operations.", current_time, expiration); 
            id(restore_svc_state).execute();
          } else {
            if (!id(status_short_cycle_lockout).state) {
               ESP_LOGI("short_cycle_mitigation", "Booted during active lockout. Re-enabling lockout sensor. (Ecodan Time: %u, Expiration: %u)", current_time, expiration);
               id(status_short_cycle_lockout).publish_state(true);
            }
          }

# compressor stop event handler
  - id: on_compressor_stop
    mode: single
    then:
      - lambda: |-
          ESP_LOGD("predictive_short_cycle", "Running compressor stop logic...");
          auto& status = id(ecodan_instance).get_status();

          // if we had adjustment prior to the end-cycle, restore the flow temperatures
          bool stand_alone_predictive_active = !id(auto_adaptive_control_enabled).state && id(predictive_short_cycle_control_enabled).state;
          float adjustment = id(predictive_short_cycle_total_adjusted);

          if (stand_alone_predictive_active && adjustment > 0.0f) {  
            ESP_LOGD("predictive_short_cycle", "Restoring flow setpoint after predictive boost.");
          
            // Subtract the total adjusted amount from the current setpoints            
            float restored_flow_z1 = status.Zone1FlowTemperatureSetPoint - adjustment;
            id(ecodan_instance).set_flow_target_temperature(restored_flow_z1, esphome::ecodan::Zone::ZONE_1);
            
            if (status.has_independent_z2()) {
              float restored_flow_z2 = status.Zone2FlowTemperatureSetPoint - adjustment;
              id(ecodan_instance).set_flow_target_temperature(restored_flow_z2, esphome::ecodan::Zone::ZONE_2);
            }                      
            // Reset the counter
            id(predictive_short_cycle_total_adjusted) = 0.0f;
          }

          // exit if lockout is disabled
          if (id(lockout_duration).active_index().value_or(0) == 0) {
            id(compressor_start_time) = 0;
            return; // 0 duration == disabled
          }

          if (id(compressor_start_time) == 0 || id(status_short_cycle_lockout).state || status.DefrostActive)
            return;

          uint32_t min_duration_ms = id(minimum_compressor_on_time).state * 60000UL;
          if (min_duration_ms == 0)
            return;

          if (status.is_heating(esphome::ecodan::Zone::ZONE_1) 
            || status.is_cooling(esphome::ecodan::Zone::ZONE_1)
            || status.is_heating(esphome::ecodan::Zone::ZONE_2) 
            || status.is_cooling(esphome::ecodan::Zone::ZONE_2)) {

              uint32_t run_duration_ms = millis() - id(compressor_start_time);
              if (run_duration_ms < min_duration_ms) {
                id(compressor_start_time) = 0; 
                id(status_short_cycle_lockout).publish_state(true);
                id(short_cycle_mitigation_script).execute();
              }
          }

binary_sensor:
  - platform: template
    id: status_predictive_boost_active
    name: ${status_predictive_boost_active}
    lambda: |-
      return (id(predictive_short_cycle_total_adjusted) > 0.0f);
  - platform: ecodan
    status_short_cycle_lockout:
      id: status_short_cycle_lockout
      name: ${status_short_cycle_lockout}
    status_compressor:
      id: status_compressor
      name: ${status_compressor}
      on_state_change:
        then:
          - lambda: |-
              // don't act on unknown -> on/off transitions
              if (x.has_value() && x_previous.has_value()) {
                // OFF -> ON
                if (!*x_previous && *x) {
                  auto& status = id(ecodan_instance).get_status();
                  if (!status.DefrostActive) {
                    ESP_LOGI(esphome::ecodan::TAG, "Compressor START detected");
                    id(compressor_start_time) = millis();
                  }
                  if (id(auto_adaptive_control_enabled).state) {
                    ESP_LOGD("auto_adaptive", "Compressor start: triggering auto-adaptive loop.");
                    id(auto_adaptive_loop).execute();
                  }
                }
                // ON -> OFF
                else if (*x_previous && !*x) {
                  ESP_LOGI(esphome::ecodan::TAG, "Compressor STOP detected");
                  id(on_compressor_stop).execute();
                }
              }